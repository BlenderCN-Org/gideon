
/** Gideon Standard Library Functions **/
module gideon {

  /* Math */

  extern function exp(float x) float : gde_exp_f;

  function min(float x, float y) float {
    if (x < y) return x;
    return y;
  }

  function max(float x, float y) float {
    if (x > y) return x;
    return y;
  }

  function clamp(float x, float low, float high) float {
    return min(max(x, low), high);
  }

  function abs(float f) float {
    if (f < 0.0) return -f;
    return f;
  }

  /* Sampling */

  extern function __cosine_sample_hemisphere(output vec3 N,
					     float rand_u, float rand_v,
					     output vec3 rt) void : gde_cosine_sample_hemisphere;
  function cosine_sample_hemisphere(vec3 N, float rand_u, float rand_v) vec3 {
    vec3 rt;
    __cosine_sample_hemisphere(N, rand_u, rand_v, rt);
    return rt;
  }

  /* Random Number Generation */

  extern function __random(scene s) float : gde_random;
  function random() float { return __random(__gd_scene); }

  /* Vector Operations */

  extern function __dot_v3(output vec3 A, output vec3 B) float : gde_dot_v3;
  function dot(vec3 A, vec3 B) float { return __dot_v3(A, B); }

  extern function __normalize_v3(output vec3 V, output vec3 N) void : gde_normalize_v3;
  function normalize(vec3 V) vec3 { vec3 N; __normalize_v3(V, N); return N; }

  extern function __length_v3(output vec3 V) float : gde_length_v3;
  function length(vec3 V) float { return __length_v3(V); }

  /* Camera */

  //Generates a ray from the camera in the direction of the given pixel.
  extern function __camera_shoot_ray(int x, int y, scene s, output ray r) void : gde_camera_shoot_ray;
  function camera:shoot_ray(int x, int y) ray {
    ray r;
    __camera_shoot_ray(x, y, __gd_scene, r);
    return r;
  }

  /* Ray/Intersection Access */

  extern function __isect_distance(output isect i) float : gde_isect_dist;
  function isect:distance(isect i) float { return __isect_distance(i); }

  extern function __isect_normal(output isect i, scene s, output vec3 N) void : gde_isect_normal;
  function isect:normal(isect i) vec3 { vec3 N; __isect_normal(i, __gd_scene, N); return N; }

  extern function __isect_smooth_normal(output isect i, scene s, output vec3 N) void : gde_isect_smooth_normal;
  function isect:smooth_normal(isect i) vec3 { vec3 N; __isect_smooth_normal(i, __gd_scene, N); return N; }

  extern function __isect_primitive_id(output isect i) int : gde_isect_primitive_id;
  function isect:primitive_id(isect i) int { return __isect_primitive_id(i); }

  extern function __ray_point_on_ray(output ray r, float t, output vec3 P) void : gde_ray_point_on_ray;
  function ray:point_on_ray(ray r, float t) vec3 { vec3 P; __ray_point_on_ray(r, t, P); return P; }

  extern function __ray_origin(output ray r, output vec3 O) void : gde_ray_origin;
  function ray:origin(ray r) vec3 { vec3 O; __ray_origin(r, O); return O; }

  /* Object/Primitive Access */

  extern function __primitive_shader(scene s, int p) shader_handle : gde_primitive_shader;
  function primitive:shader(int p) shader_handle { return __primitive_shader(__gd_scene, p); }
  
  /* Scene Query */

  //Traces a ray through the scene.
  extern function __trace(output ray r, output isect hit,
			  output int aabb_count, output int prim_count, scene s) bool : gde_trace;
  function trace(ray r, output isect hit) bool {
    int unused;
    return __trace(r, hit, unused, unused, __gd_scene);
  }

  function trace(ray r, output isect hit, output int aabb_count, output int prim_count) bool {
    return __trace(r, hit, aabb_count, prim_count, __gd_scene);
  }

  /* Lights */
  
  //Returns the number of lights in the current scene.
  extern function __scene_num_lights(scene s) int : gde_scene_num_lights;
  function scene:num_lights() int { return __scene_num_lights(__gd_scene); }

  //Returns a reference to a light in the scene.
  extern function __scene_get_light(scene s, int id, output light l) void : gde_scene_get_light;
  function scene:get_light(int id) light {
    light l;
    __scene_get_light(__gd_scene, id, l);
    return l;
  }

  //Given two uniform random numbers in [0, 1], samples a position on the given light.
  //If the position's 'w' coordinate is 0, the light is directional.
  extern function __light_sample_position(light lt, output vec3 P, float rand_u, float rand_v,
					  output float pdf, output vec4 P_out) void : gde_light_sample_position;
  function light:sample_position(light lt, vec3 P, float rand_u, float rand_v, output float pdf) vec4 {
    vec4 P_out;
    __light_sample_position(lt, P, rand_u, rand_v, pdf, P_out);
    return P_out;
  }
  
  //Evaluates the radiance of the light at the given point.
  extern function __light_eval_radiance(light lt, output vec3 P, output vec3 I,
					output vec4 R) void : gde_light_eval_radiance;
  function light:eval_radiance(light lt, vec3 P, vec3 I) vec4 {
    vec4 R;
    __light_eval_radiance(lt, P, I, R);
    return R;
  }
  
  /* Shading */

  //Evaluates a distribution function.
  extern function __dfunc_eval(output dfunc d,
			       output vec4 L_in,
			       output vec3 P_in, output vec3 w_in,
			       output vec3 P_out, output vec3 w_out,
			       output float pdf, output vec4 out) void : gde_dfunc_eval;
  function dfunc:evaluate(dfunc d,
			  vec4 L_in,
			  vec3 P_in, vec3 w_in,
			  vec3 P_out, vec3 w_out,
			  output float pdf) vec4 {
    vec4 out;
    __dfunc_eval(d, L_in, P_in, w_in, P_out, w_out, pdf, out);
    return out;
  }

  //Samples a distribution function.
  extern function __dfunc_sample(output dfunc d,
				 output vec3 P_out, output vec3 w_out,
				 output vec2 rand_P, output vec2 rand_w,
				 output vec3 P_in, output vec3 w_in) float : gde_dfunc_sample;
  function dfunc:sample(dfunc d,
			vec3 P_out, vec3 w_out,
			vec2 rand_P, vec2 rand_w,
			output vec3 P_in, output vec3 w_in) float {
    return __dfunc_sample(d, P_out, w_out, rand_P, rand_w, P_in, w_in);
  }

  //Returns true if a shader handle references a valid shader function.
  extern function shader_handle:is_valid(shader_handle h) bool : gde_shader_handle_is_valid;
  
  //Evaluates the shader of whatever object the ray hit, returning the associated distribution.
  function shade(ray r, vec2 coords, isect hit) dfunc {
    int prim_id = isect:primitive_id(hit);
    shader_handle shader = primitive:shader(prim_id);
    return dfunc(shader, r, coords, hit);
  }
  
  /* Render Output */

  //Writes a color to the output buffer at the given coordinates.
  extern function __write_pixel(int x, int y, int w, int h, output vec4 color, scene buffer) void : gde_write_pixel;
  function write_pixel(int x, int y, int w, int h, vec4 color, scene buffer) void { __write_pixel(x, y, w, h, color, buffer); }

  /* Builtin Distributions */

  /*
    Simple Lambertian Reflectance.
    Parameters:
      N -- Shading Normal
      k -- Reflectance Factor
      color -- Reflected Color
  */
  distribution lambert(vec3 N, vec3 Ng, float k, vec4 color) {

    function eval_pdf(float dot_N) float {
      float pi = 3.14159265359; 
      return abs(dot_N) / pi;
    }

    function evaluate(vec4 L_in,
		      vec3 P_in, vec3 w_in,
		      vec3 P_out, vec3 w_out,
		      output float pdf) vec4 {
      float z = dot(N, w_in);
      pdf = eval_pdf(dot(Ng, w_in));

      float fac = k*z;
      return fac * color * L_in;
    }

    function sample(vec3 P_out, vec3 w_out,
		    vec2 rand_P, vec2 rand_w,
		    output vec3 P_in, output vec3 w_in) float {
      P_in = P_out;
      w_in = cosine_sample_hemisphere(Ng, rand_w.x, rand_w.y);
      
      float z = dot(Ng, w_in);
      if ((z * dot(Ng, w_out)) < 0.0) return 0.0; //directions are on different sides of the hemisphere
      return eval_pdf(z);
    }
    
  }
}
